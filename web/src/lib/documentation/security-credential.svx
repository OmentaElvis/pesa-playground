---
title: 'Security Credential'
order: 3
summary: 'Learn how to generate the SecurityCredential required for certain Daraja API calls using an RSA public key.'
---

# Security Credential Generation

For certain sensitive operations, such as making payments from a business account, the Daraja API requires an encrypted `SecurityCredential`. This credential ensures that the request is coming from a legitimate source with the authority to perform the action.

## Business Operators

A **Business Operator** is essentially a sub-user account associated with a specific business shortcode. Each operator has a username and a password. In Pesa Playground, you can create and manage operators for your businesses in the Business page of a project section.

The password of the operator is the value that you will encrypt to create the `SecurityCredential`.

## APIs Requiring a SecurityCredential

The following APIs implemented in Pesa Playground require a valid `SecurityCredential`:

- [B2C Payment](/info/b2c)
- [Account Balance Query](/info/balance_query)

## Generating the Credential

The `SecurityCredential` is generated by encrypting the **plain-text password** of the Business Operator using an **RSA public key** provided by the M-Pesa platform. The encrypted result is then Base64 encoded.

### Using the Pesa Playground UI

Pesa Playground provides a dedicated page at [credentials page](/settings/credentials) to simplify this process.

- You can paste an operator's password into the "Password to Encrypt" field to instantly generate the `SecurityCredential`.
- You can also copy the sandbox's public key from this page to use directly in your own backend application.

### Examples in Backend Languages

If you need to generate the credential dynamically in your application, you can use the public key provided by Pesa Playground. Here are some examples in popular languages:

#### Python (using `cryptography` library)

```python
import base64
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives import serialization

def generate_security_credential(public_key_pem, password):
    """
    Encrypts a password with an RSA public key and returns a Base64 encoded string.
    """
    public_key = serialization.load_pem_public_key(public_key_pem.encode())
    
    encrypted_password = public_key.encrypt(
        password.encode(),
        padding.PKCS1v15()
    )
    
    return base64.b64encode(encrypted_password).decode('utf-8')

# --- Usage ---
# public_key = "---BEGIN PUBLIC KEY---..." # Copied from Pesa Playground
# credential = generate_security_credential(public_key, "YourOperatorPassword")
```

#### Node.js (using built-in `crypto` module)

```javascript
const crypto = require('crypto');

function generateSecurityCredential(publicKeyPem, password) {
  const publicKey = {
    key: publicKeyPem,
    padding: crypto.constants.RSA_PKCS1_PADDING,
  };

  const encryptedPassword = crypto.publicEncrypt(publicKey, Buffer.from(password));
  
  return encryptedPassword.toString('base64');
}

// --- Usage ---
// const publicKey = `-----BEGIN PUBLIC KEY-----...`; // Copied from Pesa Playground
// const credential = generateSecurityCredential(publicKey, "YourOperatorPassword");
```

#### Java (using `javax.crypto.Cipher`)

```java
import javax.crypto.Cipher;
import java.nio.charset.StandardCharsets;
import java.security.KeyFactory;
import java.security.PublicKey;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

public class SecurityCredentialGenerator {

    public static String generate(String publicKeyPem, String password) throws Exception {
        // Remove header, footer, and newlines from PEM string
        String publicKeyClean = publicKeyPem
                .replace("-----BEGIN PUBLIC KEY-----", "")
                .replace("-----END PUBLIC KEY-----", "")
                .replaceAll("\s", "");

        byte[] keyBytes = Base64.getDecoder().decode(publicKeyClean);
        X509EncodedKeySpec spec = new X509EncodedKeySpec(keyBytes);
        KeyFactory keyFactory = KeyFactory.getInstance("RSA");
        PublicKey publicKey = keyFactory.generatePublic(spec);

        Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");
        cipher.init(Cipher.ENCRYPT_MODE, publicKey);

        byte[] encryptedBytes = cipher.doFinal(password.getBytes(StandardCharsets.UTF_8));

        return Base64.getEncoder().encodeToString(encryptedBytes);
    }
}
```

#### PHP (using `openssl_public_encrypt`)

```php
<?php
function generateSecurityCredential($publicKeyPem, $password) {
    openssl_public_encrypt(
        $password,
        $encryptedPassword,
        $publicKeyPem,
        OPENSSL_PKCS1_PADDING
    );
    
    return base64_encode($encryptedPassword);
}

// --- Usage ---
// $publicKey = "-----BEGIN PUBLIC KEY-----..."; // Copied from Pesa Playground
// $credential = generateSecurityCredential($publicKey, "YourOperatorPassword");
?>
```

---

> **Disclaimer:** The public key provided by Pesa Playground is for testing and simulation purposes only. When moving to a live environment, you **must** use the official production public key provided by Safaricom.
